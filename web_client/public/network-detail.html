<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Network Visualization - Flappy AI</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: linear-gradient(135deg, #050a14 0%, #0a1628 50%, #0d1a2a 100%);
      color: #e0f0ff;
      min-height: 100vh;
      overflow: hidden;
    }

    .container {
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 20px;
    }

    header {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 16px 24px;
      background: linear-gradient(90deg, rgba(0, 217, 255, 0.1) 0%, transparent 50%, rgba(255, 107, 157, 0.1) 100%);
      border-radius: 12px;
      border: 1px solid #2a4a6a;
      margin-bottom: 20px;
    }

    .title {
      font-size: 1.4rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .title .icon {
      font-size: 1.6rem;
    }

    .info {
      display: flex;
      gap: 16px;
      margin-left: auto;
    }

    .architecture {
      font-size: 1rem;
      color: #00d9ff;
      padding: 6px 16px;
      background: rgba(0, 217, 255, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(0, 217, 255, 0.3);
    }

    .params {
      font-size: 0.9rem;
      color: #8899aa;
      display: flex;
      align-items: center;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(0, 255, 136, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(0, 255, 136, 0.3);
      color: #00ff88;
      font-size: 0.85rem;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: #00ff88;
      border-radius: 50%;
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }

    .svg-container {
      flex: 1;
      background: radial-gradient(ellipse at center, #0d1a2a 0%, #050a14 100%);
      border-radius: 12px;
      border: 1px solid #1a2a3a;
      overflow: hidden;
      position: relative;
    }

    #network-svg {
      width: 100%;
      height: 100%;
    }

    .layer-label {
      font-size: 16px;
      font-weight: 600;
      fill: #00d9ff;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .layer-size {
      font-size: 12px;
      fill: #6688aa;
    }

    .node-label {
      font-size: 11px;
      fill: #aabbcc;
    }

    .node-label.output {
      font-size: 14px;
      font-weight: 600;
      fill: #e0f0ff;
    }

    .node-value {
      font-size: 9px;
      fill: #ffffff;
      font-weight: 600;
    }

    .node-value.output {
      font-size: 11px;
    }

    footer {
      display: flex;
      gap: 32px;
      padding: 16px 24px;
      background: rgba(10, 22, 40, 0.9);
      border-radius: 12px;
      border: 1px solid #1a2a3a;
      margin-top: 20px;
    }

    .legend-section h4 {
      font-size: 0.75rem;
      color: #6688aa;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .legend-items {
      display: flex;
      gap: 20px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: #8899aa;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #3a4a5a;
    }

    .legend-color.relu-high {
      background: linear-gradient(135deg, #00ffaa 0%, #00d9ff 100%);
    }

    .legend-color.relu-medium {
      background: #00b8d4;
    }

    .legend-color.relu-low {
      background: #4a8a7a;
    }

    .legend-color.relu-zero {
      background: #2a3a4a;
    }

    .decision-display {
      display: flex;
      align-items: center;
      gap: 24px;
    }

    .action {
      font-size: 1.2rem;
      font-weight: 700;
      padding: 8px 20px;
      border-radius: 10px;
    }

    .action.idle {
      color: #00d9ff;
      background: rgba(0, 217, 255, 0.15);
      border: 2px solid #00d9ff;
    }

    .action.flap {
      color: #ff6b9d;
      background: rgba(255, 107, 157, 0.15);
      border: 2px solid #ff6b9d;
      animation: flap-glow 0.5s ease-in-out infinite alternate;
    }

    @keyframes flap-glow {
      from { box-shadow: 0 0 10px rgba(255, 107, 157, 0.3); }
      to { box-shadow: 0 0 25px rgba(255, 107, 157, 0.6); }
    }

    .q-comparison {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .q-val {
      font-size: 0.9rem;
      color: #6688aa;
      padding: 4px 10px;
      border-radius: 6px;
    }

    .q-val.winner {
      font-weight: 600;
    }

    .q-val.idle.winner {
      color: #00d9ff;
      background: rgba(0, 217, 255, 0.15);
    }

    .q-val.flap.winner {
      color: #ff6b9d;
      background: rgba(255, 107, 157, 0.15);
    }

    /* Activation function plot */
    .activation-function {
      margin-left: auto;
    }

    .function-plot-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .function-plot {
      width: 160px;
      height: 100px;
      background: rgba(5, 10, 20, 0.5);
      border-radius: 6px;
      border: 1px solid #2a3a4a;
    }

    .function-labels {
      display: flex;
      justify-content: space-between;
      width: 130px;
      font-size: 0.65rem;
      color: #6688aa;
      margin-top: 2px;
    }

    .zero-label {
      color: #6688aa;
    }

    .pos-label {
      color: #00d9ff;
    }

    .no-data {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #6688aa;
    }

    .no-data h2 {
      font-size: 1.5rem;
      margin-bottom: 10px;
      color: #8899aa;
    }

    .no-data p {
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1 class="title">
        <span class="icon">ðŸ§ </span>
        Neural Network Visualization
      </h1>
      <div class="info">
        <span class="architecture">6 â†’ 64 â†’ 64 â†’ 2</span>
        <span class="params">4,738 parameters</span>
        <div class="status">
          <div class="status-dot"></div>
          <span>LIVE</span>
        </div>
      </div>
    </header>

    <div class="svg-container">
      <svg id="network-svg" viewBox="0 0 1200 600" preserveAspectRatio="xMidYMid meet">
        <defs>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
        
        <!-- Background grid -->
        <g class="grid" opacity="0.08">
          <line x1="0" y1="0" x2="0" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="100" y1="0" x2="100" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="200" y1="0" x2="200" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="300" y1="0" x2="300" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="400" y1="0" x2="400" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="500" y1="0" x2="500" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="600" y1="0" x2="600" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="700" y1="0" x2="700" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="800" y1="0" x2="800" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="900" y1="0" x2="900" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="1000" y1="0" x2="1000" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="1100" y1="0" x2="1100" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
          <line x1="1200" y1="0" x2="1200" y2="600" stroke="#4a90a4" stroke-width="0.5"/>
        </g>

        <!-- Layer labels -->
        <g id="layer-labels"></g>
        
        <!-- Edges -->
        <g id="edges"></g>
        
        <!-- Nodes -->
        <g id="nodes"></g>
      </svg>
      
      <div class="no-data" id="no-data">
        <h2>Waiting for data...</h2>
        <p>Start training in the main window to see the neural network</p>
      </div>
    </div>

    <footer>
      <div class="legend-section">
        <h4>ReLU Activation Colors</h4>
        <div class="legend-items">
          <div class="legend-item">
            <div class="legend-color relu-high"></div>
            <span>Strong activation</span>
          </div>
          <div class="legend-item">
            <div class="legend-color relu-medium"></div>
            <span>Medium</span>
          </div>
          <div class="legend-item">
            <div class="legend-color relu-low"></div>
            <span>Weak</span>
          </div>
          <div class="legend-item">
            <div class="legend-color relu-zero"></div>
            <span>Zero (dead)</span>
          </div>
        </div>
      </div>
      <div class="legend-section">
        <h4>Current Decision</h4>
        <div class="decision-display">
          <span class="action idle" id="action-display">â†’ IDLE</span>
          <div class="q-comparison">
            <span class="q-val idle" id="q-idle">Q(idle): 0.000</span>
            <span class="q-val flap" id="q-flap">Q(flap): 0.000</span>
          </div>
        </div>
      </div>
      <div class="legend-section activation-function">
        <h4>Activation Function: ReLU(x)</h4>
        <div class="function-plot-container">
          <svg class="function-plot" viewBox="0 0 160 100" preserveAspectRatio="xMidYMid meet">
            <defs>
              <linearGradient id="reluGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:#2a3a4a" />
                <stop offset="50%" style="stop-color:#2a3a4a" />
                <stop offset="60%" style="stop-color:#4a8a7a" />
                <stop offset="80%" style="stop-color:#00d9ff" />
                <stop offset="100%" style="stop-color:#00ffaa" />
              </linearGradient>
            </defs>
            <!-- Axes -->
            <line x1="20" y1="50" x2="150" y2="50" stroke="#4a5a6a" stroke-width="1" />
            <line x1="85" y1="10" x2="85" y2="90" stroke="#4a5a6a" stroke-width="1" />
            <!-- Axis labels -->
            <text x="155" y="54" fill="#6688aa" font-size="8">x</text>
            <text x="88" y="15" fill="#6688aa" font-size="8">f(x)</text>
            <text x="12" y="54" fill="#6688aa" font-size="7">-3</text>
            <text x="145" y="54" fill="#6688aa" font-size="7">3</text>
            <text x="88" y="18" fill="#6688aa" font-size="7">3</text>
            <text x="88" y="88" fill="#6688aa" font-size="7">0</text>
            <!-- ReLU curve -->
            <path id="reluCurve" fill="none" stroke="url(#reluGradient)" stroke-width="2.5" stroke-linecap="round" />
            <!-- Color bar below -->
            <rect x="20" y="92" width="130" height="6" rx="2" fill="url(#reluGradient)" />
          </svg>
          <div class="function-labels">
            <span class="zero-label">Zero (xâ‰¤0)</span>
            <span class="pos-label">Positive (x>0)</span>
          </div>
        </div>
      </div>
    </footer>
  </div>

  <script>
    const INPUT_LABELS = ['y', 'vel', 'dxâ‚', 'dyâ‚', 'dxâ‚‚', 'dyâ‚‚'];
    const OUTPUT_LABELS = ['IDLE', 'FLAP'];
    
    const SVG_WIDTH = 1200;
    const SVG_HEIGHT = 600;
    const LAYER_POSITIONS = [120, 400, 700, 1080];
    const INPUT_NODE_RADIUS = 20;
    const HIDDEN_NODE_RADIUS = 6;
    const OUTPUT_NODE_RADIUS = 28;

    function getNodeColor(activation) {
      // ReLU outputs are always >= 0
      // 0 = dead/inactive (gray), positive = active (cyan gradient)
      const normalized = Math.max(0, Math.min(2, activation));
      
      if (normalized < 0.05) {
        return '#2a3a4a'; // Dead neuron (gray)
      } else {
        // Scale from teal to bright cyan based on activation strength
        const intensity = Math.min(1, normalized / 1.5);
        const r = Math.floor(0 + intensity * 0);
        const g = Math.floor(120 + intensity * 135);
        const b = Math.floor(160 + intensity * 95);
        return `rgb(${r}, ${g}, ${b})`;
      }
    }

    function getNodeStroke(activation) {
      if (activation < 0.05) return '#4a5a6a'; // Dead neuron
      return '#00ff88'; // Active neuron
    }


    function formatValue(v) {
      if (Math.abs(v) < 0.01) return '0';
      return v.toFixed(2);
    }

    function formatQValue(v) {
      if (v === 0) return '0.000';
      if (Math.abs(v) < 0.001) return v.toExponential(1);
      if (Math.abs(v) >= 100) return v.toExponential(1);
      return v.toFixed(3);
    }

    function renderNetwork(data) {
      const { activations, qValues, selectedAction } = data;
      const inputValues = activations[0] || [0, 0, 0, 0, 0, 0];
      
      document.getElementById('no-data').style.display = 'none';
      
      const labelsGroup = document.getElementById('layer-labels');
      const edgesGroup = document.getElementById('edges');
      const nodesGroup = document.getElementById('nodes');
      
      // Clear previous content
      labelsGroup.innerHTML = '';
      edgesGroup.innerHTML = '';
      nodesGroup.innerHTML = '';
      
      // Layer labels
      const layerNames = ['Input', 'Hidden 1', 'Hidden 2', 'Output'];
      const layerSizes = ['6 nodes', '64 nodes', '64 nodes', '2 nodes'];
      
      LAYER_POSITIONS.forEach((x, i) => {
        const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        labelText.setAttribute('x', x);
        labelText.setAttribute('y', 35);
        labelText.setAttribute('class', 'layer-label');
        labelText.setAttribute('text-anchor', 'middle');
        labelText.textContent = layerNames[i];
        labelsGroup.appendChild(labelText);
        
        const sizeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        sizeText.setAttribute('x', x);
        sizeText.setAttribute('y', SVG_HEIGHT - 15);
        sizeText.setAttribute('class', 'layer-size');
        sizeText.setAttribute('text-anchor', 'middle');
        sizeText.textContent = layerSizes[i];
        labelsGroup.appendChild(sizeText);
      });
      
      // Calculate input node positions
      const inputNodes = [];
      const inputSpacing = (SVG_HEIGHT - 150) / 5;
      for (let i = 0; i < 6; i++) {
        inputNodes.push({
          x: LAYER_POSITIONS[0],
          y: 75 + i * inputSpacing,
          activation: inputValues[i] || 0,
          label: INPUT_LABELS[i]
        });
      }
      
      // Hidden layer node positions (4 columns x 16 rows = 64 nodes representation)
      // Compute pseudo-activations based on weighted sum of inputs (simulating ReLU-like behavior)
      const hiddenLayers = [[], []];
      
      // Layer 1: Each hidden node receives weighted combination of all inputs
      const x1 = LAYER_POSITIONS[1];
      const rows = 16;
      const cols = 4;
      const rowSpacing = (SVG_HEIGHT - 120) / (rows - 1);
      const colSpacing = 18;
      const colOffset = -((cols - 1) * colSpacing) / 2;
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const idx = row * cols + col;
          // Weighted sum of inputs with pseudo-random but deterministic weights
          let preActivation = 0;
          for (let i = 0; i < 6; i++) {
            const weight = Math.sin((idx * 7 + i * 13) * 0.1) * 0.5;
            preActivation += inputValues[i] * weight;
          }
          // Apply ReLU activation function: max(0, x)
          const activation = Math.max(0, preActivation);
          
          hiddenLayers[0].push({
            x: x1 + colOffset + col * colSpacing,
            y: 60 + row * rowSpacing,
            activation: activation
          });
        }
      }
      
      // Layer 2: Each node receives weighted combination from layer 1
      const x2 = LAYER_POSITIONS[2];
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const idx = row * cols + col;
          // Weighted sum from layer 1 nodes
          let preActivation = 0;
          for (let i = 0; i < 64; i++) {
            const weight = Math.sin((idx * 11 + i * 5) * 0.05) * 0.3;
            preActivation += hiddenLayers[0][i].activation * weight;
          }
          // Apply ReLU activation function: max(0, x)
          const activation = Math.max(0, preActivation);
          
          hiddenLayers[1].push({
            x: x2 + colOffset + col * colSpacing,
            y: 60 + row * rowSpacing,
            activation: activation
          });
        }
      }
      
      // Output node positions
      const outputNodes = [
        { x: LAYER_POSITIONS[3], y: SVG_HEIGHT / 2 - 60, activation: qValues[0], label: OUTPUT_LABELS[0] },
        { x: LAYER_POSITIONS[3], y: SVG_HEIGHT / 2 + 60, activation: qValues[1], label: OUTPUT_LABELS[1] }
      ];
      
      // Draw edges (static color for efficiency - nodes show activation colors)
      // Helper to get node index from row/col (4 cols per row)
      const nodeIdx = (row, col) => row * 4 + col;
      
      // Static edge style
      const EDGE_COLOR = '#3a4a5a';
      const EDGE_WIDTH = '0.4';
      const EDGE_OPACITY = '0.5';
      
      // Input to H1: Connect each input to nodes across ALL rows
      inputNodes.forEach((inp, inputIdx) => {
        for (let row = 0; row < 16; row++) {
          const col = (inputIdx + row) % 4;
          const h1 = hiddenLayers[0][nodeIdx(row, col)];
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', inp.x + INPUT_NODE_RADIUS);
          line.setAttribute('y1', inp.y);
          line.setAttribute('x2', h1.x);
          line.setAttribute('y2', h1.y);
          line.setAttribute('stroke', EDGE_COLOR);
          line.setAttribute('stroke-width', EDGE_WIDTH);
          line.setAttribute('opacity', EDGE_OPACITY);
          edgesGroup.appendChild(line);
        }
      });
      
      // H1 to H2: Connect ALL rows with distribution across columns
      for (let srcRow = 0; srcRow < 16; srcRow++) {
        for (let srcCol = 0; srcCol < 4; srcCol += 2) {
          const h1 = hiddenLayers[0][nodeIdx(srcRow, srcCol)];
          const dstRow = (srcRow + 3) % 16;
          const dstCol = (srcCol + 1) % 4;
          const h2 = hiddenLayers[1][nodeIdx(dstRow, dstCol)];
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', h1.x + HIDDEN_NODE_RADIUS);
          line.setAttribute('y1', h1.y);
          line.setAttribute('x2', h2.x - HIDDEN_NODE_RADIUS);
          line.setAttribute('y2', h2.y);
          line.setAttribute('stroke', EDGE_COLOR);
          line.setAttribute('stroke-width', EDGE_WIDTH);
          line.setAttribute('opacity', EDGE_OPACITY);
          edgesGroup.appendChild(line);
        }
      }
      
      // H2 to Output: Connect ALL rows to both outputs
      for (let row = 0; row < 16; row++) {
        for (let col = 0; col < 4; col += 2) {
          const h2 = hiddenLayers[1][nodeIdx(row, col)];
          outputNodes.forEach((out, outIdx) => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', h2.x + HIDDEN_NODE_RADIUS);
            line.setAttribute('y1', h2.y);
            line.setAttribute('x2', out.x - OUTPUT_NODE_RADIUS);
            line.setAttribute('y2', out.y);
            line.setAttribute('stroke', EDGE_COLOR);
            line.setAttribute('stroke-width', EDGE_WIDTH);
            line.setAttribute('opacity', EDGE_OPACITY);
            edgesGroup.appendChild(line);
          });
        }
      }
      
      // Draw input nodes
      inputNodes.forEach((node, i) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', INPUT_NODE_RADIUS);
        circle.setAttribute('fill', getNodeColor(node.activation));
        circle.setAttribute('stroke', getNodeStroke(node.activation));
        circle.setAttribute('stroke-width', 2);
        if (Math.abs(node.activation) > 0.5) {
          circle.setAttribute('filter', 'url(#glow)');
        }
        g.appendChild(circle);
        
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', -INPUT_NODE_RADIUS - 10);
        label.setAttribute('y', 4);
        label.setAttribute('class', 'node-label');
        label.setAttribute('text-anchor', 'end');
        label.textContent = node.label;
        g.appendChild(label);
        
        const value = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        value.setAttribute('y', 4);
        value.setAttribute('class', 'node-value');
        value.setAttribute('text-anchor', 'middle');
        value.textContent = formatValue(node.activation);
        g.appendChild(value);
        
        nodesGroup.appendChild(g);
      });
      
      // Draw hidden layer nodes
      hiddenLayers.forEach((layer) => {
        layer.forEach((node) => {
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', node.x);
          circle.setAttribute('cy', node.y);
          circle.setAttribute('r', HIDDEN_NODE_RADIUS);
          circle.setAttribute('fill', getNodeColor(node.activation));
          circle.setAttribute('stroke', getNodeStroke(node.activation));
          circle.setAttribute('stroke-width', 1);
          circle.setAttribute('opacity', 0.85);
          nodesGroup.appendChild(circle);
        });
      });
      
      // Draw output nodes
      outputNodes.forEach((node, i) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
        
        const isSelected = i === selectedAction;
        const color = isSelected ? (i === 0 ? '#00d9ff' : '#ff6b9d') : getNodeColor(node.activation);
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', OUTPUT_NODE_RADIUS);
        circle.setAttribute('fill', color);
        circle.setAttribute('stroke', isSelected ? '#ffffff' : getNodeStroke(node.activation));
        circle.setAttribute('stroke-width', 3);
        circle.setAttribute('filter', 'url(#glow)');
        g.appendChild(circle);
        
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', OUTPUT_NODE_RADIUS + 14);
        label.setAttribute('y', 5);
        label.setAttribute('class', 'node-label output');
        label.setAttribute('text-anchor', 'start');
        label.textContent = node.label;
        g.appendChild(label);
        
        const value = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        value.setAttribute('y', 5);
        value.setAttribute('class', 'node-value output');
        value.setAttribute('text-anchor', 'middle');
        value.textContent = formatQValue(node.activation);
        g.appendChild(value);
        
        nodesGroup.appendChild(g);
      });
      
      // Update footer
      const actionDisplay = document.getElementById('action-display');
      actionDisplay.textContent = selectedAction === 0 ? 'â†’ IDLE' : 'â†‘ FLAP';
      actionDisplay.className = 'action ' + (selectedAction === 0 ? 'idle' : 'flap');
      
      const qIdle = document.getElementById('q-idle');
      const qFlap = document.getElementById('q-flap');
      qIdle.textContent = `Q(idle): ${formatQValue(qValues[0])}`;
      qFlap.textContent = `Q(flap): ${formatQValue(qValues[1])}`;
      qIdle.className = 'q-val idle' + (selectedAction === 0 ? ' winner' : '');
      qFlap.className = 'q-val flap' + (selectedAction === 1 ? ' winner' : '');
    }

    // Draw the ReLU activation function curve
    function drawReluCurve() {
      const path = document.getElementById('reluCurve');
      if (!path) return;
      
      // SVG viewBox is 0 0 160 100
      // Plot area: x from 20 to 150 (130 units), y from 10 to 90 (80 units)
      // x axis: -3 to 3, y axis: 0 to 3 (ReLU output)
      const xMin = 20, xMax = 150;
      const yMin = 10, yMax = 90;
      const xRange = xMax - xMin;
      const yRange = yMax - yMin;
      
      let d = '';
      const steps = 60;
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = -3 + t * 6; // x from -3 to 3
        const y = Math.max(0, x); // ReLU: max(0, x), output 0 to 3
        
        // Convert to SVG coordinates (y from 0 to 3, map to yMax to yMin)
        const svgX = xMin + t * xRange;
        const svgY = yMax - (y / 3) * yRange; // scale and flip
        
        if (i === 0) {
          d = `M ${svgX} ${svgY}`;
        } else {
          d += ` L ${svgX} ${svgY}`;
        }
      }
      
      path.setAttribute('d', d);
    }
    
    // Draw curve on page load
    drawReluCurve();

    // Poll localStorage for updates
    function pollData() {
      try {
        const data = localStorage.getItem('flappy-ai-network-data');
        if (data) {
          const parsed = JSON.parse(data);
          renderNetwork(parsed);
        }
      } catch (e) {
        console.error('Error reading network data:', e);
      }
      requestAnimationFrame(pollData);
    }

    // Start polling
    pollData();
  </script>
</body>
</html>

