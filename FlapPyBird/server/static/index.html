<!DOCTYPE html>
<html>
<head>
    <title>Flappy Bird AI - Live View</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <h1>üê¶ Flappy Bird AI - Live View</h1>
    <div id="container">
        <canvas id="gameCanvas" width="1728" height="1024"></canvas>
    </div>
    <div id="info">
        <div class="info-item">
            <div class="label">Score</div>
            <div id="score">0</div>
        </div>
        <div class="info-item">
            <div class="label">Status</div>
            <div id="status" class="status">Connecting...</div>
        </div>
        <div class="info-item">
            <div class="label">FPS</div>
            <div id="fps">0</div>
        </div>
        <div class="info-item">
            <div class="label">Model ma50</div>
            <div id="ma50">-</div>
        </div>
        <div class="info-item" style="cursor: pointer;" id="muteBtn">
            <div class="label">Sound</div>
            <div id="soundStatus">üîä On</div>
        </div>
    </div>
    <button id="joinBtn">Join!</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const statusEl = document.getElementById('status');
        const fpsEl = document.getElementById('fps');
        const ma50El = document.getElementById('ma50');
        const muteBtn = document.getElementById('muteBtn');
        const soundStatus = document.getElementById('soundStatus');
        const joinBtn = document.getElementById('joinBtn');

        // ephemeral per-tab user id assigned by server on join
        let userId = null;

        const SCALE = 2; // Render at 2x scale for better visibility
        let gameState = null;
        let ws;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let birdFrame = 0;
        let birdAnimCounter = 0;
        let isMuted = true; // start muted by default
        let isJoined = false;
        let inputDy = 0; // -1, 0, +1

        // Load assets
        const images = {
            background: new Image(),
            floor: new Image(),
            pipeGreen: new Image(),
            birdMid: new Image(),
            birdUp: new Image(),
            birdDown: new Image(),
        };

        let assetsLoaded = 0;
        const totalAssets = Object.keys(images).length;

        function onImageLoad() {
            assetsLoaded++;
            if (assetsLoaded === totalAssets) {
                console.log('All assets loaded!');
            }
        }

        images.background.src = '/assets/sprites/background-day.png';
        images.background.onload = onImageLoad;
        images.floor.src = '/assets/sprites/base.png';
        images.floor.onload = onImageLoad;
        images.pipeGreen.src = '/assets/sprites/pipe-green.png';
        images.pipeGreen.onload = onImageLoad;
        images.birdMid.src = '/assets/sprites/yellowbird-midflap.png';
        images.birdMid.onload = onImageLoad;
        images.birdUp.src = '/assets/sprites/yellowbird-upflap.png';
        images.birdUp.onload = onImageLoad;
        images.birdDown.src = '/assets/sprites/yellowbird-downflap.png';
        images.birdDown.onload = onImageLoad;

        // Load audio
        const sounds = {
            wing: new Audio('/assets/audio/wing.ogg'),
            point: new Audio('/assets/audio/point.ogg'),
            hit: new Audio('/assets/audio/hit.ogg'),
            die: new Audio('/assets/audio/die.ogg'),
        };

        // Preload all sounds
        Object.values(sounds).forEach(sound => {
            sound.load();
            sound.volume = 0.3; // Lower volume to not be too loud
        });

        function playSound(soundName) {
            if (isMuted || !sounds[soundName]) return;
            try {
                sounds[soundName].currentTime = 0; // Reset to start
                sounds[soundName].play().catch(e => console.log('Audio play failed:', e));
            } catch (e) {
                console.log('Audio error:', e);
            }
        }

        // Mute button handler
        // init UI state
        soundStatus.textContent = isMuted ? 'üîá Off' : 'üîä On';
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            soundStatus.textContent = isMuted ? 'üîá Off' : 'üîä On';
        });

        // Join/Leave toggle
        joinBtn.addEventListener('click', () => {
            if (!ws || ws.readyState !== 1) return;
            if (!isJoined) {
                ws.send(JSON.stringify({ type: 'join_request' }));
            } else {
                ws.send(JSON.stringify({ type: 'leave', userId }));
                isJoined = false;
                userId = null;
                inputDy = 0;
                joinBtn.textContent = 'Join!';
                document.getElementById('gameCanvas').style.borderColor = '#4ecca3';
            }
        });

        // Keyboard input (while joined)
        function sendInput() {
            if (!isJoined || !ws || ws.readyState !== 1 || !userId) return;
            ws.send(JSON.stringify({ type: 'input', userId, dy: inputDy }));
        }
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') { inputDy = -1; sendInput(); }
            else if (e.key === 'ArrowDown') { inputDy = +1; sendInput(); }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') { inputDy = 0; sendInput(); }
        });

        function drawGame() {
            if (!gameState || assetsLoaded < totalAssets) return;

            const state = gameState.state;

            // Draw background (tiled)
            const bgWidth = images.background.width * SCALE;
            const bgHeight = images.background.height * SCALE;
            for (let x = 0; x < canvas.width; x += bgWidth) {
                ctx.drawImage(images.background, x, 0, bgWidth, bgHeight);
            }

            // Draw pipes (before floor so they appear behind it)
            for (const pipe of state.pipes) {
                const x = pipe.x * SCALE;
                const pipeWidth = images.pipeGreen.width * SCALE;
                const pipeHeight = images.pipeGreen.height * SCALE;

                // Upper pipe: top-left is at (x, upper_y), rotated 180 degrees
                const upperY = pipe.upper_y * SCALE;
                ctx.save();
                ctx.translate(x + pipeWidth/2, upperY + pipeHeight/2);
                ctx.rotate(Math.PI);  // Rotate 180 degrees
                ctx.drawImage(images.pipeGreen, -pipeWidth/2, -pipeHeight/2, pipeWidth, pipeHeight);
                ctx.restore();

                // Lower pipe: top-left is at (x, lower_y), drawn normally
                const lowerY = pipe.lower_y * SCALE;
                ctx.drawImage(images.pipeGreen, x, lowerY, pipeWidth, pipeHeight);

                // Highlight owned pipe for this user (electric blue tint + outline)
                if (pipe.owner && gameState.colors && gameState.colors[pipe.owner]) {
                    const c = gameState.colors[pipe.owner];
                    ctx.save();
                    const gapTop = (pipe.upper_y + images.pipeGreen.height) * SCALE;
                    const gapBottom = lowerY; // already scaled
                    const gapCenter = (gapTop + gapBottom) / 2;
                    // semi-transparent overlay using owner color
                    ctx.fillStyle = c + '40'; // add alpha if supported
                    ctx.fillRect(x, 0, pipeWidth, gapTop);
                    ctx.fillRect(x, gapBottom, pipeWidth, canvas.height - gapBottom);
                    // bold outline
                    ctx.strokeStyle = c;
                    ctx.lineWidth = 6;
                    ctx.strokeRect(x, 0, pipeWidth, gapTop);
                    ctx.strokeRect(x, gapBottom, pipeWidth, canvas.height - gapBottom);
                    // prominent label with outline for contrast
                    if (pipe.owner === userId) {
                        ctx.font = 'bold 22px Arial';
                        ctx.textBaseline = 'middle';
                        const labelY = Math.max(18, gapTop - 14);
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = '#000';
                        ctx.strokeText('YOU', x + pipeWidth/2 - 22, labelY);
                        ctx.fillStyle = c;
                        ctx.fillText('YOU', x + pipeWidth/2 - 22, labelY);
                        // arrows placed on the pipes: up on upper pipe, down on lower pipe
                        const arrowX = x + pipeWidth/2 - 8;
                        ctx.font = 'bold 26px Arial';
                        // Up arrow inside upper pipe near its lower end (above YOU)
                        const upY = Math.max(24, gapTop - 45);
                        ctx.strokeText('‚Üë', arrowX, upY);
                        ctx.fillText('‚Üë', arrowX, upY);
                        // Down arrow inside lower pipe near its top
                        const downY = gapBottom + 27;
                        ctx.strokeText('‚Üì', arrowX, downY);
                        ctx.fillText('‚Üì', arrowX, downY);
                    }
                    ctx.restore();
                }
            }

            // Draw floor (after pipes so it appears on top)
            const floorY = state.viewport_height * SCALE;
            const floorWidth = images.floor.width * SCALE;
            const floorHeight = images.floor.height * SCALE;
            const floorX = (state.floor_x * SCALE) % floorWidth;
            for (let x = -floorWidth + floorX; x < canvas.width; x += floorWidth) {
                ctx.drawImage(images.floor, x, floorY, floorWidth, floorHeight);
            }

            // Draw bird with animation
            const bird = state.bird;
            const birdX = bird.x * SCALE;
            const birdY = bird.y * SCALE;

            // Animate bird flapping (cycle through frames)
            birdAnimCounter++;
            if (birdAnimCounter % 5 === 0) {
                birdFrame = (birdFrame + 1) % 3;
            }

            const birdImages = [images.birdUp, images.birdMid, images.birdDown];
            const birdImg = birdImages[birdFrame];
            const birdWidth = birdImg.width * SCALE;
            const birdHeight = birdImg.height * SCALE;

            ctx.save();
            ctx.translate(birdX + birdWidth/2, birdY + birdHeight/2);
            ctx.rotate((bird.rotation * Math.PI) / 180);
            ctx.drawImage(birdImg, -birdWidth/2, -birdHeight/2, birdWidth, birdHeight);
            ctx.restore();

            // Update FPS
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate > 1000) {
                fpsEl.textContent = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        function animate() {
            drawGame();
            requestAnimationFrame(animate);
        }

        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => {
                statusEl.textContent = 'Connected';
                statusEl.className = 'status';
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'frame' || data.type === 'init') {
                    gameState = data;
                    // update my color and border if provided
                    if (userId && data.colors && data.colors[userId]) {
                        const myColor = data.colors[userId];
                        document.getElementById('gameCanvas').style.borderColor = myColor;
                    }
                    if (data.state) {
                        scoreEl.textContent = data.state.score;
                        const m = data.state.model_ma50;
                        if (typeof m === 'number') {
                            ma50El.textContent = m.toFixed(2);
                        } else {
                            ma50El.textContent = '-';
                        }
                    }

                    // Play sound effects based on events
                    if (data.events) {
                        if (data.events.flap) playSound('wing');
                        if (data.events.score) playSound('point');
                    }
                } else if (data.type === 'game_over') {
                    console.log('Game Over! Score:', data.score);

                    // Reset join state and UI on game reset
                    isJoined = false;
                    inputDy = 0;
                    joinBtn.textContent = 'Join!';
                    if (ws && ws.readyState === 1 && userId) {
                        ws.send(JSON.stringify({ type: 'leave', userId }));
                    }
                    userId = null;
                    document.getElementById('gameCanvas').style.borderColor = '#4ecca3';

                    // Play death sounds
                    if (data.events) {
                        if (data.events.hit) playSound('hit');
                        if (data.events.die) {
                            setTimeout(() => playSound('die'), 100);
                        }
                    }
                } else if (data.type === 'join_ok') {
                    userId = data.userId;
                    isJoined = true;
                    joinBtn.textContent = 'Leave';
                    if (data.color) {
                        document.getElementById('gameCanvas').style.borderColor = data.color;
                    }
                } else if (data.type === 'join_denied') {
                    statusEl.textContent = 'Room full (max 5)';
                    statusEl.className = 'error';
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                statusEl.textContent = 'Error';
                statusEl.className = 'error';
            };

            ws.onclose = () => {
                statusEl.textContent = 'Reconnecting...';
                statusEl.className = 'error';
                setTimeout(connect, 2000);
            };
        }

        connect();
        animate();
    </script>
</body>
</html>

